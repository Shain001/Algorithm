package com.shain.dp.array.stock;

public class BestTimeStock3_L123 {
    public int maxProfit(int[] prices) {
        // 此题dp数组的状态发生了改变。
        // stock1，2 都是每天只需记录两种状态： 持有股票， 不持有股票。
        // 但是这道题， 由于有买卖次数的绝对限制， 所以每天的状态有四种可能性：第1次持有0股， 第一次 持有1股， 第2次 持有0股， 第二次持有1股， 第3次持有0股。
        // 其中第1次持有0股， 也就是初始状态。 第3次持有0股， 也就是股票两次买卖完毕， 即所求最大利润。
        // 而这5个状态， 也即对应着 5 个列。
        int[][] dp = new int[prices.length][5];

        // 还没买过
        dp[0][0] = 0;
        // 第一次买
        dp[0][1] = -prices[0];
        // 第一次卖， 当天买当天卖当然就是0利润
        dp[0][2] = 0;
        // 第二次买， 当天就买了第二次
        dp[0][3] = -prices[0];
        // 第二次卖， 当天就卖了第二次，当然仍然是0利润
        dp[0][4] = 0;

        for (int i = 1; i < prices.length; i++) {
            // 第i天 第一次持有0股, 即到了第i天还没买卖
            dp[i][0] = 0;
            // 第一次买 -> 第一次持有1股， 可能来自于： 前一天就持有1股， 或者今天第一次买。
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
            // 第一次卖 -> 第2次持有0股， 即已经买过一次 -> 前一天就 第1次持有0股了， 或者 今天 第一次卖。
            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
            // 第二次买 -> 第2次持有1股， 即之前已经 买卖过一次， 则： 前一天就已经第二次持有1股， 或 今天是第2次买；
            dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);
            // 第二次卖 -> 第3次持有0股， 即两次买卖结束， 则： 前一天就已经买卖结束（已经第二次持有1股）， 或今天刚卖
            dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }

        return dp[dp.length-1][4];

    }
}
