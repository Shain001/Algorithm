# 数组

数组无非： 寻找重复/ 寻找target或边界 / 删除 / 添加 / 排序 / getRandom / 差分 / 前缀和

对于寻找target或边界 -> 二分 -> 见 pointer/twopoint/binarySearch/summary.md

对于 排序， 此处指的是 O(n) 实现排序， 在满足条件的情况下可以使用 原地Hash 的方法 （即 原地交换）

差分前缀和看两道题就行了， 此处略， but 对与差分/前缀和 有一些 隐式应用， to be summarized. e.g. L528 带权重的随机数（前缀和+二分）。

## O(1) 实现数组 添加 删除 指定元素 (同时满足getRandom 所有元素等概率) -> L380

首先， 时间复杂度是O(1) 了， 空间复杂度肯定得上来。 所以不用怕使用额外空间。

此处唯一值得注意的， 即怎么实现O（1） 删除某个value：

答： 如果仅仅是要求 O（1） 实现添加删除， 那么只需要用一个HashMap， 删除时直接得到index， 然后从数组移除元素就行了。难点在于还要同时保证getRandom。
这意味着"你维护的数组必须是连续的， 即所有数组中的元素是连续的" -> 通过 "先交换，再删除"实现， 具体见题。

## 寻找重复元素

### 1. 限定下标值

#### 1.1 元素范围 1-n， 数组长度n+1， 且只有一个重复元素（重复次数不限）-> 将数组转换成链表

进而， 若需要返回重复元素是什么 -> 寻找链表入口

如只需判断是否有重复 -> 判断环形链表
e.g. 187

####  1.2  元素范围 0-n-1， 数组长度为n， 可有多个重复元素 -> 原地交换（原地hash）

e.g. 剑指 Offer 03. 数组中重复的数字

**注意： 原地交换不仅可用于寻找重复元素， 也可用于寻找缺失的元素 （剑指 Offer 53 - II. 0～n-1中缺失的数字；1539. 第 k 个缺失的正整数），以及排序 （曾经面试抖音的面试题）， 总之， 只要看到 元素范围，和长度满足以上条件 -> you should realize -> 元素值
可以与下标相对应 -> 将元素放置到对应下标 （视题目要求， 可以是原数组中进行修改， 也可以创建新数组修改）**

**再注意： 原地交换 的使用提示，有可能以隐含形式出现， 并不一定局限于 元素范围 0-n-1， 数组长度为n （但是一旦显示出现该条件， you must realize）：**

e.g. L41_FirstMissingPositive: 第一个缺失的正数中， 尽管数组中元素的取值范围不是 0-n-1， 但是 **缺失的第一个正数的取值范围在 1 to n+1, where n is length of the array**

NOTE: 为什么是 1 to n+1? 因为， 与正常的 offer03 中的 元素范围0-n-1时不同（where 元素值x 直接对应下标x）， 这题需要把 元素值x对应到下标x-1：

e.g. [3,2,1] -> 如果 x对应x-1 -> [3,1,2] -> 遍历时 for (1 to end) -> 你就漏掉了3。 换句话说， 该题在重新对数组排列完以后， "必须从0开始遍历数组"


为什么L41 是原地交换？根本原因在于， 你只需要寻找缺失的"正数"， 不论你想找第几个都无所谓。因为：

There is only three possibilities for the numbers in an array：

1） 所有元素都 不在 1-n 的区间内 （不论元素值是正还是负，只要对不到下标上） -> 所有元素都无法与下标对应 -> 进行原地交换以后， 下标1处的元素值 ≠ 1， 1就是第一个缺失的正数
2） 所有元素都在 1-n 区间内， 所有元素都能被交换到对应下标 -> e.g. [-10, 1, 2, 3, 4] -> 5 就是第一个缺失正数
3） 部分元素可以对应到 区间上 -> e.g. [0, 1, 2, -100, 80, 10, 6, 7, 8] -> -100 对应的下标 就是target

## 删除重复项/移动0

### 1. 数组有序， 或者 移动0 这种：
快慢指针， 慢指针总是在copy快指针， 快指针用于筛选符合条件的元素。
此处 **L26 删除重复元素， 之所以能够通过快慢指针进行， 有一个很重要的条件是 "数组有序"**。why? e.g. [1,2,2,1] 慢指针在index=1， fast=index=2
此时通过快慢指针的方法删除则依然会有重复 -> [1,2,1,x], 因为你只能记录两个值， 你不知道slow指针的左边还有哪些数。

**换句话说， 当数组有序时， 可以通过快慢指针remove duplicate， 或者， 可以通过 先排序， 在remove 的操作进行。 -> 时间换空间**

### 2. 无序数组/字符串：
**首先， 只要是 无序， 在不进行排序的情况下， 要进行remove duplicate 就必定使用 额外空间， 比如hashMap， 或者在 对字符串去重时可以使用长度为256的数组记录count （A-Z ASCII = 65 to 90; a-Z = 97 to 122），**

**在要保证去重之后， 元素间顺序不变的情况下 -> 可以使用stack操作去重。**

**要保证去重之后， 不仅元素间顺序不变， 还要保证"字典序最小" （当然，int顺序也同理） -> 单调栈 -> 尽量保持栈顶元素最小（L1081）**
