# 重中之重-背包问题的信号

通常用于 在一个 数组中 找 和为 target 的 元素集合。 注意这些元素不一定连续。
当然， 可能是 判断 有没有 sum = target 的 -> true/false
或者 sum=target 的集合有多少种组合 -> int
或者 sum <= target 的最大值是多少 -> int

以上都是 "组合数问题， 即 {1,3} 等同于{3, 1}". 还可能是 "排列数问题， 即 {1, 3} 不等于 {3.1}". 此时只需要 "用一维dp，
并在外层循环 遍历 容量 （只限完全背包， 01 的外层
必须是 物品）" e.g. L377 -> 这个问题还没仔细研究。 先记者就行。 Q: 那么01 背包有没有 排列数问题？ 有的话怎么办？ Q：
为什么外层遍历容量就是 排列？ -> 需debug一下， 同时
find out the root and think about if this can happen to 01 pack, and what if it happen to 01 pack.

# 补充： 为什么 完全背包问题中， 使用一维数组外层遍历 物品， 内层遍历容量得到的是 组合数， 反过来是 排列数？

原因根源在于 当 使用 一维数组时， 是一种对二维数组的简化， 这就导致了， 当 外层遍历容量时， 你计算每一个 dp[i] 时用到的 dp[i] 和 dp[i-n] 的值，
实际是包含了 所有硬币可能性的值。 举个例子。

[1, 2， 8] 求 sum = 3 的组合数。  

首先 明确dp方程为 dp[i] + dp[i-n] 

如果外层遍历 coins， 内层遍历amount：

则你的dp数组是 横向的， 一次一次刷新的对吧。 即
dp 的值从  [m1, m2, m3] -> [m1', m2', m3'] 

这代表着， 当你计算 coins = 2 时的 dp[3] 时， 用到的 dp[i] 只包含 coin=1 时的可能性，  dp[i-n] 则只包含 coin=1，2 时 得出的 结果。
这就是组合数， 因为没有 重复计算。

如果外层遍历 amount, 那么你的数组其实是一位一位竖着更新的， 即
dp 的值从 [m1, m2, ,m3] -> [m1', m2, m3] -> [m1'', m2, m3] 
所以你计算 到m2时， 数组的情况是 [m1''， m2, m3] , 即 dp中 前面的数都已经是完全计算完了的。 这代表着：

当你计算 coins=2 时的 dp[3] 时， 用到的 dp[i] 意义没变， 但是用到的 dp[i-n] 这个值， 他的计算是包含了 coins中所有元素的， 即 1,2,8都包含了，
所以相当于排列数。

# 0-1 背包问题 vs 完全背包问题：

0-1： 每个元素最多可以选一次。
完全： 每个元素可以选无限次。

这带来什么不同？

## dp 方程：

0-1：

当选择了当前元素以后， dp[i][j] 的值， 由 dp[i-1][j-nums[i]] 计算得来。 因为已经不能再次选择当前元素， 可选的
元素范围 由 0-i (对应dp[i]) 变成了 0- i-1。

完全：

当选择了当前元素以后， dp[i][j] 的值， 仍旧取决于 dp[i][j-nums[i]]， 因为可选择的元素范围仍然是 0-i。

对于不选择当前元素的情况， 两者一样， dp[i][j] 取决于 dp[i-1][j]

## 初始化：

### 0-1：

数组可以是 boolean[][] dp = new boolean[nums.length][target + 1]; （还问验证是否可以也初始化成 numLen+1， 如果可以，
统一成numLen+1）

然后在初始化数组时， 初始化第一行 dp[0][nums[0]] = true; （see L416）

update:
数组应该初始化成 n 行， 还是n+1 行 （n为nums长度）， 需要视情况而定:

如 L416, 初始化成n+1 行， 并且初始化dp[0][0] = true 也能得出正确结果。 但是不够严谨。因为dp代表含义是， 0-i 元素中， 能不能相加得到
sum=j.

此时 dp00 表示一个数都不选， 能不能得到和为0？ 如果为true， 显然没有意义， 但是因为输入的元素中都是正整数， 所以
无论怎么选择1-n个元素， 都不可能得到0这个和， 所以这样初始化没有影响。

但是如L494 题， 所求的值是 最大组合数n， dp含义是 0-i 间的元素， 有多少种可能性相加得到 j。 并且最重要的， nums中可能包含0。
此时 "必须" 初始
化成 n+1 行， 第0行代表一个数字都不选。 然后初始化 dp[0][0]=1, "即如果一个元素都不选， '能够' 得到和为0"。 其实细想也有点不对劲，
但是必须这样 做。

！ 因为如果初始化成 n 行， 第0行就代表 i=0 下标的元素。 此时你无法准确初始化第0行中每个格子的值， 具体看L494 中的注视以及例子。

update about L494: 之所以它初始化dp[0][0] = 1， 是因为他的递归方程中没有 1+ xxx 这个操作， 即：

正常来想， 每个格子能够得到 target 的可能性 = 选择自身 (1 + dp[i-1][j-nums[i]]; 因为选择自身本身就是一种可能， 所以+1) +
不选自身 （dp[i-1][j]）

但是 由于 L494 解法中， dp初始化成了 len+1 行， 且dp[0][0] 初始话为1， 所以 dp返程中不需要再+1 了， 因为 dp[0][0] 已经等于1
了。
你拿 i = 1 时举例， dp[1][nums[j]] 本来是应该通过 dp[i][j] = 1 + dp[i-1][j-nums[i] 得到1，
但是由于现在初始化 dp[0][0] = 1 了, 所以 dp[i-1][j-nums[i] 就=1， 不用再加1。

之所以需要这样操作， 是因为 在 input = [1] target =1 或 input = [1,0] target = 1 这种情况时， 正常写法会出错， 因为此时
newTarget = 0; 无法进入for循环。

### 完全：

初始化时 dp长宽必须都是+1。 并且对于 i= 1 行的计算， 必须通过dp方程完成。 理由是， 0-1 这种初始化方式只适用于 一个元素
只能使用一次的情况。
e.g. L518: 假设 input 为 nums = [5], amount = 10, 这样会只更新到 dp[5]=1, 而漏掉了 dp[10]=1。

而由于i=1 这一行不能通过特例进行初始化了， 其值只能通过dp方程进行运算， 而dp方程运算中又要用到 dp[i-1][j], 所以必须要有第0行。
而第0行的意义为： 下标0-0， 即空元素， 那么自然 无论 j 为何值， dp值都为0， 所以全部初始化为0即可/=。

### 关于初始化 n 行还是 n+1行总结

#### 对于0-1 背包问题：

需要初始化n行， 还是n+1 行， 取决于 如果初始化成 n 行， 你能否直接准确的正确初始化 第0行的所有格子的值。 如果可以， 则n行，
不可以， 则n+1行。

比如 L416， dp每个格子代表的是 0-i 中能不能相加得到 j？ 那么第一行自然只有 dp[nums[0]] = true, 其他都是false。

但是像 L494， 由于 有 0 的存在， 你无法 在 行数=n 时初始化 第0行元素。

#### 对于完全背包

至少目前来看， 应该是必须初始化 n+1行， 因为"完全背包中每个元素可以被选择无限次"， 所以如果初始化成n行， 第0行元素直接对应
第0个元素， 你仍然需要通过
dp方程才能得到每个格子的值。 而不可以像 L416 一样直接初始化第0行。

#### 当初始化成 n+1 行时 dp数组中value的初始化

通常只需要初始化dp[0][0] 即可， 具体的值， 当然需要视情况判断。
当然， 也可能有情况是需要初始化 第0行和第0列， 但是目前还没遇到 （大概率没有这种情况）。
但是无论如何， 只需要记住， 此时第0行表示 "一个元素都不选"， 然后视 题干， 以及 j 的意义进行初始化选择即可。

## Update：

### 0-1 背包

**题型**

1. 找 sum = target 返回true false -> L416 ->
2. 找 sum = target 返回 组合数量 -> L494 -> 具体见题， dp 方程为： dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];
3. 找 sum = target， 返回 '小于等于' target 的最大值 -> L1049

**General dp方程**
对于找 背包重量下， 最大值的方程：

二维dp：
不选当前： dp[i - 1][j]
选当前： dp[i - 1][j - weight[i]] + value[i]

dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

一维dp：
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

需要注意， 大部分题中， weight和value的意义都是一样的。 比如L416， 494， 1049. 这种数组类型的， weight就是目标和。
value当然也就是元素值

**遍历顺序**
对于二维dp： 横着更新竖着更新都可以。 但是你习惯 横着更新。

对于一维dp：

"必须" 在外围 for loop 中遍历 物品， 内层 loop中遍历容量；

并且， "必须从右到左反向更新dp数组"， 因为你永远要用到 左侧 的值

### 完全背包

**题型**

1. 计算 nums中， sum = target 所需要的最小硬币数 -> dp[i][j] = Math.min(1 + dp[i][j-coins[i-1]], dp[i-1][j]);
2. 计算 nums中， sum=target 的组合数量 -> dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; -> 需把第一列都初始化为1，
   如果是一维dp： dp[j] = dp[j-coin] + dp[j];
   dp[0] 需初始化为1

**General方程**

二维dp：

不选当前： dp[i - 1][j]
选当前： dp[i][j - weight[i]] + value[i]  -> 由于可以重复选取同一个物品， 选了当前物品以后， 无需在将 i上移

dp[i][j] = max(dp[i][j], dp[i - 1][j - weight[i]] + value[i])

一维dp：
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

你会发现， 一维dp的方程， 对于 0-1 还是完全没有区别。 为什么？ 因为二维dp方程中， 两者唯一区别就是， 选取了当前元素以后需不需要上移i，
那么在一维dp
中， 由于所有行，都被压缩了一行， 那么你只需要怎么做就能达到上移i的效果？ -> "更改更新dp的顺序， 即从左到右 更新 dp数组"

**遍历顺序**

求"组合"时 （即 {1,3} 等同于 {3, 1}）内外层loop顺序无所谓， 所以还是按照 外围遍历 物品， 也就是相当于 横着更新二维数组即可。e.g.
L518; 5 yuan + 3 yuan = 8 yuan.

更新 顺序必须是 左到右正向更新。

但是如果是求"排列" ({1, 3} 不同于 {3,1}), 那么必须外层是 loop 容量， 内层 loop 物品。 e.g. L377

### 关于dp数组初始化问题

只要是计算"组合数" 的类型， 都需要初始化 n+1 行， 无论 是完全还是01， 此时 第0行代表什么都不选， 且dp[0][0] 表示， 什么都不选时得到
target=0 有1 中选择。
所以 dp[0][0] = 1, dp[0][1-n] = 0。 这样做的原因， 因为 初始化问题 方程为： dp[i][j] = dp[i - 1][j] + dp[i][j -
coins[i - 1]] / dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];

两个方程中都没有 +x 的操作， 所以如果你不初始化， 你的dp中永远没有值， 全是0。

其余的类型题， 具体看题判断把， 但是 完全背包是基本要初始化为n+1 行的， 因为这样方便操作。 01背包基本上都可以初始化为n行。

但无论怎么样， 只要 "理解好dp数组的意义， 以及i， j 的含义， 那么就无需担心做错"， "其中唯一需要注意的是， 当初始化为n+1行，
第0行就代表什么都不选， 那么此时"：

1. 什么都不选， 得到 容量为0的背包， 算是一种选择方案， 即选择数=1； -> This is why L494 L518 初始化[0][0] = 1
2. 什么都不选， 得到 容量为0的背包， 需要选择几个物品？ -> 0 个。-> This is why L322 初始化[0][0] = 0