# 0-1 背包问题 vs 完全背包问题：

0-1： 每个元素最多可以选一次。
完全： 每个元素可以选无限次。

这带来什么不同？

## dp 方程：

0-1：

当选择了当前元素以后， dp[i][j] 的值， 由 dp[i-1][j-nums[i]] 计算得来。 因为已经不能再次选择当前元素， 可选的
元素范围 由 0-i (对应dp[i]) 变成了 0- i-1。

完全：

当选择了当前元素以后， dp[i][j] 的值， 仍旧取决于 dp[i][j-nums[i]]， 因为可选择的元素范围仍然是 0-i。

对于不选择当前元素的情况， 两者一样， dp[i][j] 取决于 dp[i-1][j]

## 初始化：

### 0-1：

数组可以是 boolean[][] dp = new boolean[nums.length][target + 1]; （还问验证是否可以也初始化成 numLen+1， 如果可以，
统一成numLen+1）
然后在初始化数组时， 初始化第一行 dp[0][nums[0]] = true; （see L416）

update:
数组应该初始化成 n 行， 还是n+1 行 （n为nums长度）， 需要视情况而定:

如 L416, 初始化成n+1 行， 并且初始化dp[0][0] = true 也能得出正确结果。 但是不够严谨。因为dp代表含义是， 0-i 元素中， 能不能相加得到
sum=j.
此时 dp00 表示一个数都不选， 能不能得到和为0？ 如果为true， 显然没有意义， 但是因为输入的元素中都是正整数， 所以
无论怎么选择1-n个元素， 都不可能
得到0这个和， 所以这样初始化没有影响。

但是如L494 题， 所求的值是 最大组合数n， dp含义是 0-i 间的元素， 有多少种可能性相加得到 j。 并且最重要的， nums中可能包含0。
此时 "必须" 初始
化成 n+1 行， 第0行代表一个数字都不选。 然后初始化 dp[0][0]=1, "即如果一个元素都不选， '能够' 得到和为0"。 其实细想也有点不对劲，
但是必须这样
做。

！ 因为如果初始化成 n 行， 第0行就代表 i=0 下标的元素。 此时你无法准确初始化第0行中每个格子的值， 具体看L494 中的注视以及例子。

### 完全：

初始化时 dp长宽必须都是+1。 并且对于 i= 1 行的计算， 必须通过dp方程完成。 理由是， 0-1 这种初始化方式只适用于 一个元素
只能使用一次的情况。
e.g. L518: 假设 input 为 nums = [5], amount = 10, 这样会只更新到 dp[5]=1, 而漏掉了 dp[10]=1。

而由于i=1 这一行不能通过特例进行初始化了， 其值只能通过dp方程进行运算， 而dp方程运算中又要用到 dp[i-1][j], 所以必须要有第0行。
而第0行的意义为： 下标0-0， 即空元素， 那么自然 无论 j 为何值， dp值都为0， 所以全部初始化为0即可/=。

### 关于初始化 n 行还是 n+1行总结

#### 对于0-1 背包问题：

需要初始化n行， 还是n+1 行， 取决于 如果初始化成 n 行， 你能否直接准确的正确初始化 第0行的所有格子的值。 如果可以， 则n行，
不可以， 则n+1行。

比如 L416， dp每个格子代表的是 0-i 中能不能相加得到 j？ 那么第一行自然只有 dp[nums[0]] = true, 其他都是false。

但是像 L494， 由于 有 0 的存在， 你无法 在 行数=n 时初始化 第0行元素。

#### 对于完全背包

至少目前来看， 应该是必须初始化 n+1行， 因为"完全背包中每个元素可以被选择无限次"， 所以如果初始化成n行， 第0行元素直接对应
第0个元素， 你仍然需要通过
dp方程才能得到每个格子的值。 而不可以像 L416 一样直接初始化第0行。

#### 当初始化成 n+1 行时 dp数组中value的初始化

通常只需要初始化dp[0][0] 即可， 具体的值， 当然需要视情况判断。
当然， 也可能有情况是需要初始化 第0行和第0列， 但是目前还没遇到 （大概率没有这种情况）。
但是无论如何， 只需要记住， 此时第0行表示 "一个元素都不选"， 然后视 题干， 以及 j 的意义进行初始化选择即可。


