# 0-1 背包问题 vs 完全背包问题：
 
0-1： 每个元素最多可以选一次。
完全： 每个元素可以选无限次。

这带来什么不同？

## dp 方程：

0-1： 

当选择了当前元素以后， dp[i][j] 的值， 由 dp[i-1][j-nums[i]] 计算得来。 因为已经不能再次选择当前元素， 可选的
元素范围 由 0-i (对应dp[i]) 变成了 0- i-1。

完全：

当选择了当前元素以后， dp[i][j] 的值， 仍旧取决于 dp[i][j-nums[i]]， 因为可选择的元素范围仍然是 0-i。


对于不选择当前元素的情况， 两者一样， dp[i][j] 取决于 dp[i-1][j]

## 初始化：

0-1：

数组可以是 boolean[][] dp = new boolean[nums.length][target + 1]; （还问验证是否可以也初始化成 numLen+1， 如果可以， 统一成numLen+1）
然后在初始化数组时， 初始化第一行 dp[0][nums[0]] = true; （see L416）

完全： 

初始化时 dp长宽必须都是+1。 并且对于 i= 1 行的计算， 必须通过dp方程完成。 理由是， 0-1 这种初始化方式只适用于 一个元素
只能使用一次的情况。 
e.g. L518: 假设 input 为 nums = [5], amount = 10,  这样会只更新到 dp[5]=1, 而漏掉了 dp[10]=1。

而由于i=1 这一行不能通过特例进行初始化了， 其值只能通过dp方程进行运算， 而dp方程运算中又要用到 dp[i-1][j], 所以必须要有第0行。
而第0行的意义为： 下标0-0， 即空元素， 那么自然 无论 j 为何值， dp值都为0， 所以全部初始化为0即可/=。

